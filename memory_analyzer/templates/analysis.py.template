# -*- mode: python -*-
# Copyright (c) Facebook, Inc. and its affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

try:
  import objgraph
  import os
  import sys
  import random
  import inspect
  import re
  import gc
  from pympler import muppy, summary
  import pickle
  import guppy

  try:
      from types import InstanceType
  except ImportError:
      # Python 3.x
      InstanceType = None


  class SwallowPrints:
      def __enter__(self):
          self._old_stdout = sys.stdout
          sys.stdout = open(os.devnull, 'w')

      def __exit__(self, exc_type, exc_val, exc_tb):
          sys.stdout.close()
          sys.stdout = self._old_stdout

  def _get_obj_type(obj):
      objtype = type(obj)
      if type(obj) == InstanceType:
          objtype = obj.__class__
      return objtype

  def _repr(obj):
      objtype = _get_obj_type(obj)
      name = objtype.__name__
      module = getattr(objtype, '__module__', None)
      if module:
          return f"{module}.{name}"
      else:
          return name

  summary._repr = _repr

  def forward_references(dirname, obj, shortname):
    filename_forw = f'{dirname}/ref_{{ pid }}_{shortname}.png'
    objgraph.show_refs([obj], shortnames=False, refcounts=True, filename=filename_forw, filter=lambda x: not type(x).__module__.startswith('guppy'))
    return filename_forw

  def backwards_references(dirname, obj, shortname):
    filename_back = f'{dirname}/backref_{{ pid }}_{shortname}.png'
    objgraph.show_backrefs([obj], shortnames=False, refcounts=True, filename=filename_back, filter=lambda x: not type(x).__module__.startswith('guppy'))
    return filename_back

  def create_references(row):
      objname = f"{row.kind}"
      dirname = os.path.dirname("{{ output_path }}")
      try:
        objs = random.choice(row.byrcs[0].byid).theone
        with SwallowPrints():
          forw = forward_references(dirname, objs, objname)
          back = backwards_references(dirname, objs, objname)
      except IndexError:
        print(f"Unable to get objects of type {objname}. Note that the GC does not track simple objects like int or str.")
        forw = back = None
      return forw, back

  gc.collect()
  heap = guppy.hpy()
  heap_status = heap.heap()
  heap_summ = [[row.name, row.count, row.size] for row in heap_status.stat.get_rows()]
  heapu_stat = heap.heapu()
  heapu_summ = [[f"{row.name} (leaked)", row.count, row.size] for row in heapu_stat.get_rows()]

  summ = heap_summ + heapu_summ
  if {{ num_refs }} > 0:
    summ.sort(key=lambda x: x[2], reverse=True)
    for i in range({{ num_refs }}):
      row = heap_status[i]
      forw, back = create_references(row)
      summ[i].extend([forw, back])

  for obj in {{ specific_refs }}:
    for i in range(len(heap_status)):
      if obj == str(heap_status[i].kind):
        row = heap_status[i]
        forw, back = create_references(row)
        summ[i].extend([forw, back])
        break

  with open('/tmp/memanz_pipe_{{ pid }}', 'wb') as fifo:
      pickle.dump(summ, fifo)

except Exception as e:
    print("Got exception", e)
    import pickle
    # We don't want exceptions here to affect the profiled process but want to
    # see the exceptions in the UI
    with open('/tmp/memanz_pipe_{{ pid }}', 'wb') as fifo:
        pickle.dump(e, fifo)
